# ステートマシン図を作ってみよう

source: `{{ page.path }}`

## ステートマシン図の追加
メニューより「図」→「ステートマシン図」を選択し、新規ステートマシン図を作成します。

<center>
<img src="../1_scrum/img/png" width="80%"></img>
</center>

## 開始疑似状態の追加
まずは、ステートマシン図の起点を表す、開始疑似状態を追加します。


## 状態の追加
開始疑似状態を追加したら、状態を追加します。
今回は、前進する状態の「FORWARD」、旋回する状態の「TURN」の2つを追加してください。状態名の変更はクラス名を変更と同様に、状態名をクリックすると自由に変更ができます。

1. 状態を選択します。
1. ステートマシン図上に、状態を配置します。

<center>
<img src="../1_scrum/img/png" width="80%"></img>
</center>

## 状態のアクティビティの指定
状態の内部には、アクティビティと呼ばれる処理を指定できます。このアクティビティ の設定を行い、その状態内でどのような動作を行うか決定します。
状態のアクティビティには、「入場動作（entry）」「実行活動（do）」「退場動作（exit）」の 3 つが指定できます。

- 入場動作（entry）
  - 状態へ遷移されたタイミングで実行されるアクティビティです。
- 実行活動（do）
  - 状態内で継続的に実行されるアクティビティです。
  - ※『継続的に』をどのように扱うかによってコードの生成の仕方が変わる場合があります。LED-Campで行うコード生成では、実行活動(do)に記載された処理はその状態のときに周期的に実行されます。
  - これは、LED-Campで扱うシステムが、基本的に周期的に実行される処理となっているからです。
- 退場動作（exit）
  - その状態からでるタイミングで実行されるアクティビティです。

これらのアクティビティを指定します。
今回の実習では、モデル図からコード生成する際、C++言語のコードを出力します。そのため、アクティビティはC++言語で指定します。

1. アクティビティを指定する状態を選択します。
1. 左側のビューの「入場/実行/退場」タブを選択します。
1. 実行活動を指定します。「FORWARD」状態では、LEDTankを100cm先まで移動します。また、その都度、走行した距離の「distance」と旋回角度の「angle」を取得します。

ControllerのAPIとして、LEDTankのモータを駆動する「ChangeDriveMode」メソッドと、走行した距離、旋回角度を取得する「getPosition」メソッドを使用します。

|                |                                                   |
| -------------- | ------------------------------------------------- |
| 【関数名】     | changeDriveMode(Mode mode, int voltage_level)       |
| 【動作・意味】 | LEDTankを動作モードと、出力を指定して駆動します。           |
| 【引数】       | mode：動作モード<br>指定できる動作モードは以下の通り。<br>STOP：停止<br>FORWARD：前進<br>BACKWARD：バック<br>CW：右旋回<br>CCW：左旋回<br>voltage_level：モータの出力を指定します。<br>弱）0～10（強）で指定をします。|
| 【戻り値】                     |  なし                                 |

|                |                                                   |
| -------------- | ------------------------------------------------- |
| 【関数名】     | getPosition(double* distance, double* angle)       |
| 【動作・意味】 | LEDTankの走行した距離、旋回角度を取得します。           |
| 【引数】       | distance：LEDTankの走行した距離を取得します。<br>angle：LEDTankの旋回角度を取得します。<br>※distance、angleは、起動時からの累積した走行距離、旋回角度を取得します。<br>累積を初期化するにはresetメソッドを呼び出します<br>（事前実習の後半で使用しますので今は気にしないでもよいです）|
| 【戻り値】                     |  なし       |

m2tプラグインではクラス図に描かれたクラス名の先頭を小文字にしたインスタンスを自動的に生成します。そのためここでは、「controller->changeDriveMode(FORWARD, 5);」と設定します。

<span style="color:red">※ C++言語なので、セミコロンを忘れないようにしてください。</span>  
また、複数行処理を記述することもできます。

4. 次に入場動作を指定します。入場状態では、現在の状態の出力と、走行距離を設定します。現在の状態の出力は C++言語のprintf関数を使用します。
「printf("[FORWARD]\n");」としてください。

<center>
<img src="../1_scrum/img/png" width="80%"></img>
</center>

|   |   |
|---|---|
|入場動作：|printf("[FORWARD]\n");<br>controller->changeDriveMode(FORWARD, 5);|
|実行活動：|	controller->getPosition(&distance, &angle);|
|退場動作：|	なし|

FORWARD状態のアクティビティを設定したら同様に、STOP状態のアクティビティを設定します。
「FORWARD」状態では、LEDTankを右旋回します。
下記表のように設定をしてください。

|   |   |
|---|---|
| 入場動作：|printf("[TURN]\n");<br>| controller->changeDriveMode(CW, 5);|
| 実行活動：|controller->getPosition(&distance, &angle);|
| 退場動作：|なし|


## 遷移の追加
状態を配置し終えたら、遷移を追加します。

1. 遷移を選択します。
1. 「FORWARD」と「TURN」を接続します。(接続した遷移は、中ほどをドラッグすると折り曲げることができます。)

## 遷移のアクティビティの指定
遷移を追加したら、遷移のアクティビティを指定します。 遷移のアクティビティには「トリガ」、「ガード」、「アクション」の3つがあります。
トリガ
状態が遷移するきっかけとなるイベントを指定します。
ガード
トリガに指定したイベントが発生したときに、ガードに指定した条件が真であった場合は遷移をします。偽であった場合は、遷移をしません。
アクション
アクションは、遷移が起きるときに実行されます。
これらのアクティビティを指定していきます。

① アクティビティを指定したい遷移を選択します。
② トリガに「E_CHANGE_DISTANCE」を指定します。
③ ガード条件に「distance > 100.0」を指定します。



トリガ：	E_CHANGE_DISTANCE
ガード：	distance > 100.0
アクション：	なし


「E_CHANGE_DISTANCE」イベントは、LEDTankの走行距離が変化したときに発生するイベントです。LEDTankが走行すると、「E_CHANGE_DISTANCE」イベントが発生します。そのときの走行距離を比較してdistanceが100.0（単位はcmです）より大きければ遷移します。

※1 ステートマシン図上ではトリガ[ガード条件]のように表示されます。
※2 状態から無条件で遷移したい場合は「TRUE」イベントを使用します。

 これで、「FORWARD」から「TURN」への遷移ができました。


また、下記の表、図のように、「TURN」から「FORWARD」への遷移の追加も行ってください。「TURN」から「FORWARD」へのトリガは「E_CHANGE_ANGLE」となります。これは旋回角度が変化したときに発生するイベントです。今回は90deg旋回したいので、ガード条件は「angle > 90.0」（単位はdegです）とします。



トリガ：	E_CHANGE_ANGLE
ガード：	angle > 90.0
アクション：	なし


また、開始疑似状態から「FORWARD」への遷移も追加してください。こちらにはアクティビティは必要ありません。

